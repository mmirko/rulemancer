// Code generated by re2go 4.0.2 on Tue Jan 27 11:46:23 2026, DO NOT EDIT.
//go:generate re2go $INPUT -o $OUTPUT --api simple
package game

import (
	"fmt"
	"errors"
)

const (
	ScopeMain = 0 + iota
	ScopeComment
)

type scopeStack struct {
	stack []int
}

func newScopeStack() *scopeStack {
	return &scopeStack{stack: make([]int, 0)}
}

func (s *scopeStack) push(scope int) int {
	s.stack = append(s.stack, scope)
	return scope
}

func (s *scopeStack) pop() int {
	if len(s.stack) > 0 {
		s.stack = s.stack[:len(s.stack)-1]
		scope := s.stack[len(s.stack)-1]
		return scope
	}
	return -1
}

func (s *scopeStack) descend(scope int) int {
	for {
		if s.stack[len(s.stack)-1] == scope {
			return scope
		}

		curr := s.pop()
		if curr == -1 {
			return -1
		}
	}
	return -1
}

func (s *scopeStack) String() string {
	result := "["
	for i := 0 ; i < len(s.stack); i++ {
		result += scopeName(s.stack[i])
		if i < len(s.stack)-1 {
			result += ", "
		}
	}
	result += "]"
	return result
}

func scopeName(scope int) string {
	switch scope {
	case ScopeMain:
		return "main"
	case ScopeComment:
		return "comment"
	}
	return "unknown"
}

// Returns "fake" terminating null if cursor has reached limit.
func peek(str string, cur int) byte {
	if cur >= len(str) {
		return 0 // fake null
	} else {
		return str[cur]
	}
}

type GameParser struct {
	*Config
} 

func (h * GameParser) Lex(relation string, yyinput string) error {
	yycursor:= 0
	yytext:= 0
	yymarker:= 0
	prev:= 0
	scope:= ScopeMain
	sS := newScopeStack()
	sS.push(scope)

	for {
		if h.Debug {
			fmt.Println("----")
			fmt.Println("yycursor:", yycursor, "yytext:", yytext, "yymarker:", yymarker)
			fmt.Println("scopeStack:", sS.String())
			fmt.Println("scope:", scopeName(scope))
			fmt.Println(">>>>")
		}

		switch scope {
		case ScopeMain:
			if h.Debug {
				fmt.Println("Scope Main entered")
			}
		 	
{
	var yych byte
	yych = yyinput[yycursor]
	switch (yych) {
	case 0x00:
		goto yy1
	case '\t':
		fallthrough
	case ' ':
		goto yy4
	case '\n':
		goto yy6
	case ';':
		goto yy8
	case 'r':
		goto yy9
	default:
		goto yy2
	}
yy1:
	yycursor += 1
	{ return nil }
yy2:
	yycursor += 1
yy3:
	{ return errors.New("Unexpected input: "+string(yyinput[prev:yycursor])) }
yy4:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case '\t':
		fallthrough
	case ' ':
		goto yy4
	default:
		goto yy5
	}
yy5:
	{
					//fmt.Println("space:", yyinput[prev:yycursor])
					prev = yycursor
					continue
				}
yy6:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case '\n':
		goto yy6
	default:
		goto yy7
	}
yy7:
	{
					//fmt.Println("newline:", yyinput[prev:yycursor])
					prev = yycursor
					continue
				}
yy8:
	yycursor += 1
	{
					scope = sS.push(ScopeComment)
					prev = yycursor
					continue
				}
yy9:
	yycursor += 1
	yymarker = yycursor
	yych = yyinput[yycursor]
	switch (yych) {
	case 'e':
		goto yy10
	default:
		goto yy3
	}
yy10:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'l':
		goto yy12
	default:
		goto yy11
	}
yy11:
	yycursor = yymarker
	goto yy3
yy12:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'a':
		goto yy13
	default:
		goto yy11
	}
yy13:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 't':
		goto yy14
	default:
		goto yy11
	}
yy14:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'i':
		goto yy15
	default:
		goto yy11
	}
yy15:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'o':
		goto yy16
	default:
		goto yy11
	}
yy16:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'n':
		goto yy17
	default:
		goto yy11
	}
yy17:
	yycursor += 1
	{
					scope = sS.push(ScopeMain)
					prev = yycursor
					continue
				}
}

		case ScopeComment:
			if h.Debug {
				fmt.Println("Scope Comment entered")
			}
			
{
	var yych byte
	yych = yyinput[yycursor]
	switch (yych) {
	case 0x00:
		goto yy19
	case '\n':
		goto yy21
	default:
		goto yy20
	}
yy19:
	yycursor += 1
	{ return errors.New("Unexpected end of input") }
yy20:
	yycursor += 1
	{
					prev = yycursor
					continue
				}
yy21:
	yycursor += 1
	{
					scope = sS.pop()
					prev = yycursor
					continue
				}
}

		}
	}
}
