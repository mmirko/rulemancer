// Code generated by re2go 4.0.2 on Thu Feb  5 10:58:29 2026, DO NOT EDIT.
//go:generate re2go $INPUT -o $OUTPUT --api simple
package rulemancer

import (
	"errors"
	"fmt"
)

const (
	ScopeMain = 0 + iota
	ScopeComment
	ScopeBlock
	ScopeDefTemplate
	ScopeSlot
	ScopeMultiSlot
)

type scopeData struct {
	blockDepth int
	name       string
}

type scopeLevel struct {
	*ProtocolData
	*scopeData
	scopeId int
	prev    *scopeLevel
	next    *scopeLevel
}

func newScopeLevel(e *ProtocolData, scope int) (*scopeLevel, int) {
	return &scopeLevel{ProtocolData: e, scopeData: &scopeData{}, scopeId: scope, prev: nil, next: nil}, scope
}

func (s *scopeLevel) push(scope int) (*scopeLevel, int) {
	sl, _ := newScopeLevel(s.ProtocolData, scope)
	sl.prev = s
	s.next = sl
	if s.Debug {
		fmt.Println(purple("scope:"), sl)
	}
	return sl, sl.scopeId
}

func (s *scopeLevel) pop() (*scopeLevel, int) {
	if s.prev == nil {
		return s, ScopeMain
	}
	prev := s.prev
	s.prev = nil
	prev.next = nil
	if s.Debug {
		fmt.Println(purple("scope:"), prev)
	}
	return prev, prev.scopeId
}

func (s *scopeLevel) descend(scope int) (*scopeLevel, int) {
	for {
		if s.scopeId == scope {
			return s, s.scopeId
		}

		if s.prev == nil {
			break
		}
		newDesc := s.prev
		s.prev = nil
		s.next = nil
		newDesc.next = nil
		s = newDesc
	}
	return s, ScopeMain
}

func (s *scopeLevel) isInsideScope(scope int) *scopeLevel {
	for desc := s; desc != nil; desc = desc.prev {
		if desc.scopeId == scope {
			return desc
		}
	}
	return nil
}

func (s *scopeLevel) isCurrentScope(scope int) bool {
	return s.scopeId == scope
}

func (s *scopeLevel) currentScope() int {
	return s.scopeId
}

func (s *scopeLevel) String() string {
	result := ""
	desc := s
	for {
		if desc == nil {
			break
		}
		result = cyan(scopeName(desc.scopeId)) + result
		if desc.prev != nil {
			result = ", " + result
		}
		desc = desc.prev
	}
	result = "[" + result + "]"
	return result
}

func scopeName(scope int) string {
	switch scope {
	case ScopeMain:
		return "main"
	case ScopeComment:
		return "comment"
	case ScopeBlock:
		return "block"
	case ScopeDefTemplate:
		return "deftemplate"
	case ScopeSlot:
		return "slot"
	case ScopeMultiSlot:
		return "multislot"
	}
	return "unknown"
}

// Returns "fake" terminating null if cursor has reached limit.
func peek(str string, cur int) byte {
	if cur >= len(str) {
		return 0 // fake null
	} else {
		return str[cur]
	}
}

func (e *ProtocolData) Compile(yyinput string) error {
	yycursor := 0
	yytext := 0
	yymarker := 0
	prev := 0
	sS, scope := newScopeLevel(e, ScopeMain)

	for {
		if e.Debug && e.DebugLevel >= debugLevelMax {
			fmt.Println("----")
			fmt.Println("yycursor:", yycursor, "yytext:", yytext, "yymarker:", yymarker)
			fmt.Println("scopeStack:", sS.String())
			fmt.Println("scope:", scopeName(scope))
			fmt.Println(">>>>")
		}

		switch scope {
		case ScopeMain:
		 	
{
	var yych byte
	yych = yyinput[yycursor]
	switch (yych) {
	case 0x00:
		goto yy1
	case '\t':
		fallthrough
	case ' ':
		goto yy3
	case '\n':
		goto yy5
	case '(':
		goto yy7
	case ';':
		goto yy8
	default:
		goto yy2
	}
yy1:
	yycursor += 1
	{ return nil }
yy2:
	yycursor += 1
	{ return errors.New("Unexpected input: "+string(yyinput[prev:yycursor])) }
yy3:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case '\t':
		fallthrough
	case ' ':
		goto yy3
	default:
		goto yy4
	}
yy4:
	{
					//fmt.Println("space:", yyinput[prev:yycursor])
					prev = yycursor
					continue
				}
yy5:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case '\n':
		goto yy5
	default:
		goto yy6
	}
yy6:
	{
					//fmt.Println("newline:", yyinput[prev:yycursor])
					prev = yycursor
					continue
				}
yy7:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeBlock)
					sS.blockDepth = sS.prev.blockDepth + 1
					prev = yycursor
					continue
				}
yy8:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeComment)
					prev = yycursor
					continue
				}
}

		case ScopeComment:
			
{
	var yych byte
	yych = yyinput[yycursor]
	switch (yych) {
	case 0x00:
		goto yy10
	case '\n':
		goto yy12
	default:
		goto yy11
	}
yy10:
	yycursor += 1
	{ return errors.New("Unexpected end of input") }
yy11:
	yycursor += 1
	{
					prev = yycursor
					continue
				}
yy12:
	yycursor += 1
	{
					sS, scope = sS.pop()
					prev = yycursor
					continue
				}
}

		case ScopeBlock:
			
{
	var yych byte
	yych = yyinput[yycursor]
	switch (yych) {
	case 0x00:
		goto yy14
	case '(':
		goto yy17
	case ')':
		goto yy18
	case ';':
		goto yy19
	case 'd':
		goto yy20
	case 'm':
		goto yy21
	case 's':
		goto yy22
	default:
		goto yy15
	}
yy14:
	yycursor += 1
	{ return errors.New("Unexpected end of input") }
yy15:
	yycursor += 1
yy16:
	{
					prev = yycursor
					continue
				}
yy17:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeBlock)
					sS.blockDepth += 1
					prev = yycursor
					continue
				}
yy18:
	yycursor += 1
	{
					sS, scope = sS.pop()
					prev = yycursor
					continue
				}
yy19:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeComment)
					prev = yycursor
					continue
				}
yy20:
	yycursor += 1
	yymarker = yycursor
	yych = yyinput[yycursor]
	switch (yych) {
	case 'e':
		goto yy23
	default:
		goto yy16
	}
yy21:
	yycursor += 1
	yymarker = yycursor
	yych = yyinput[yycursor]
	switch (yych) {
	case 'u':
		goto yy25
	default:
		goto yy16
	}
yy22:
	yycursor += 1
	yymarker = yycursor
	yych = yyinput[yycursor]
	switch (yych) {
	case 'l':
		goto yy26
	default:
		goto yy16
	}
yy23:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'f':
		goto yy27
	default:
		goto yy24
	}
yy24:
	yycursor = yymarker
	goto yy16
yy25:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'l':
		goto yy28
	default:
		goto yy24
	}
yy26:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'o':
		goto yy29
	default:
		goto yy24
	}
yy27:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 't':
		goto yy30
	default:
		goto yy24
	}
yy28:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 't':
		goto yy31
	default:
		goto yy24
	}
yy29:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 't':
		goto yy32
	default:
		goto yy24
	}
yy30:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'e':
		goto yy33
	default:
		goto yy24
	}
yy31:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'i':
		goto yy34
	default:
		goto yy24
	}
yy32:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeSlot)
					prev = yycursor
					continue
				}
yy33:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'm':
		goto yy35
	default:
		goto yy24
	}
yy34:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 's':
		goto yy36
	default:
		goto yy24
	}
yy35:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'p':
		goto yy37
	default:
		goto yy24
	}
yy36:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'l':
		goto yy38
	default:
		goto yy24
	}
yy37:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'l':
		goto yy39
	default:
		goto yy24
	}
yy38:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'o':
		goto yy40
	default:
		goto yy24
	}
yy39:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'a':
		goto yy41
	default:
		goto yy24
	}
yy40:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 't':
		goto yy42
	default:
		goto yy24
	}
yy41:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 't':
		goto yy43
	default:
		goto yy24
	}
yy42:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeMultiSlot)
					prev = yycursor
					continue
				}
yy43:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case 'e':
		goto yy44
	default:
		goto yy24
	}
yy44:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeDefTemplate)
					prev = yycursor
					continue
				}
}

		case ScopeDefTemplate:
			
{
	var yych byte
	yych = yyinput[yycursor]
	switch (yych) {
	case 0x00:
		goto yy46
	case '(':
		goto yy48
	case ')':
		goto yy49
	case ';':
		goto yy50
	case 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z':
		goto yy51
	default:
		goto yy47
	}
yy46:
	yycursor += 1
	{ return errors.New("Unexpected end of input") }
yy47:
	yycursor += 1
	{
					prev = yycursor
					continue
				}
yy48:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeBlock)
					sS.blockDepth = 1
					prev = yycursor
					continue
				}
yy49:
	yycursor += 1
	{	
					sS, scope = sS.descend(ScopeMain)
					prev = yycursor
					continue
				}
yy50:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeComment)
					prev = yycursor
					continue
				}
yy51:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case '-':
		fallthrough
	case '0','1','2','3','4','5','6','7','8','9':
		fallthrough
	case 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
		fallthrough
	case '_':
		fallthrough
	case 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z':
		goto yy51
	default:
		goto yy52
	}
yy52:
	{
					//fmt.Println("deftemplate varname:", yyinput[prev:yycursor])
					relation:= yyinput[prev:yycursor]
					if _, exists := sS.slots[relation]; exists {
						sS.name = relation
					}
					prev = yycursor
					continue
				}
}

		case ScopeMultiSlot:
			
{
	var yych byte
	yych = yyinput[yycursor]
	switch (yych) {
	case 0x00:
		goto yy54
	case '(':
		goto yy56
	case ')':
		goto yy57
	case ';':
		goto yy58
	default:
		goto yy55
	}
yy54:
	yycursor += 1
	{ return errors.New("Unexpected end of input") }
yy55:
	yycursor += 1
	{
					prev = yycursor
					continue
				}
yy56:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeBlock)
					sS.blockDepth = 1
					prev = yycursor
					continue
				}
yy57:
	yycursor += 1
	{	
					sS, scope = sS.descend(ScopeDefTemplate)
					prev = yycursor
					continue
				}
yy58:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeComment)
					prev = yycursor
					continue
				}
}

		case ScopeSlot:
			
{
	var yych byte
	yych = yyinput[yycursor]
	switch (yych) {
	case 0x00:
		goto yy60
	case '(':
		goto yy62
	case ')':
		goto yy63
	case ';':
		goto yy64
	case 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z':
		goto yy65
	default:
		goto yy61
	}
yy60:
	yycursor += 1
	{ return errors.New("Unexpected end of input") }
yy61:
	yycursor += 1
	{
					prev = yycursor
					continue
				}
yy62:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeBlock)
					sS.blockDepth = 1
					prev = yycursor
					continue
				}
yy63:
	yycursor += 1
	{	
					sS, scope = sS.descend(ScopeDefTemplate)
					prev = yycursor
					continue
				}
yy64:
	yycursor += 1
	{
					sS, scope = sS.push(ScopeComment)
					prev = yycursor
					continue
				}
yy65:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case '-':
		fallthrough
	case '0','1','2','3','4','5','6','7','8','9':
		fallthrough
	case 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
		fallthrough
	case '_':
		fallthrough
	case 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z':
		goto yy65
	default:
		goto yy66
	}
yy66:
	{
					//fmt.Println("slot varname:", yyinput[prev:yycursor])
					slotName := yyinput[prev:yycursor]
					deftempl:= sS.isInsideScope(ScopeDefTemplate)
					if deftempl != nil && deftempl.name != "" {
						if slotList, exists := sS.slots[deftempl.name]; exists {
							sS.slots[deftempl.name] = append(slotList, slotName)
						}
					}
					prev = yycursor
					continue
				}
}

		}
	}
}
