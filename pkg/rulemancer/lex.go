// Code generated by re2go 4.0.2 on Mon Feb  2 12:16:15 2026, DO NOT EDIT.
//go:generate re2go $INPUT -o $OUTPUT --api simple
package rulemancer

import (
	"fmt"
	"errors"
)

const (
	ScopeMain = 0 + iota
	ScopeComment
)

type scopeStack struct {
	*Engine
	debugLevel int
	stack []int
}

func newScopeStack(g *Engine) *scopeStack {
	return &scopeStack{Engine: g, stack: make([]int, 0)}
}

func (s *scopeStack) push(scope int) int {
	s.stack = append(s.stack, scope)
	if s.Debug {
		fmt.Println(purple("scope:"), s)
	}
	return scope
}

func (s *scopeStack) pop() int {
	if len(s.stack) > 0 {
		s.stack = s.stack[:len(s.stack)-1]
		scope := s.stack[len(s.stack)-1]
		if s.Debug {
			fmt.Println(purple("scope:"), s)
		}
		return scope
	}
	return -1
}

func (s *scopeStack) descend(scope int) int {
	for {
		if s.stack[len(s.stack)-1] == scope {
			return scope
		}

		curr := s.pop()
		if curr == -1 {
			return -1
		}
	}
	return -1
}

func (s *scopeStack) String() string {
	result := "["
	for i := 0 ; i < len(s.stack); i++ {
		result += cyan(scopeName(s.stack[i]))
		if i < len(s.stack)-1 {
			result += ", "
		}
	}
	result += "]"
	return result
}

func scopeName(scope int) string {
	switch scope {
	case ScopeMain:
		return "main"
	case ScopeComment:
		return "comment"
	}
	return "unknown"
}

// Returns "fake" terminating null if cursor has reached limit.
func peek(str string, cur int) byte {
	if cur >= len(str) {
		return 0 // fake null
	} else {
		return str[cur]
	}
}

func (g * Engine) Compile(yyinput string) error {
	yycursor:= 0
	yytext:= 0
	yymarker:= 0
	prev:= 0
	scope:= ScopeMain
	sS := newScopeStack(g)
	sS.push(scope)

	for {
		if g.Debug && g.DebugLevel >= debugLevelMax {
			fmt.Println("----")
			fmt.Println("yycursor:", yycursor, "yytext:", yytext, "yymarker:", yymarker)
			fmt.Println("scopeStack:", sS.String())
			fmt.Println("scope:", scopeName(scope))
			fmt.Println(">>>>")
		}

		switch scope {
		case ScopeMain:
		 	
{
	var yych byte
	yych = yyinput[yycursor]
	switch (yych) {
	case 0x00:
		goto yy1
	case '\t':
		fallthrough
	case ' ':
		goto yy4
	case '\n':
		goto yy6
	case '/':
		goto yy8
	default:
		goto yy2
	}
yy1:
	yycursor += 1
	{ return nil }
yy2:
	yycursor += 1
yy3:
	{ return errors.New("Unexpected input: "+string(yyinput[prev:yycursor])) }
yy4:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case '\t':
		fallthrough
	case ' ':
		goto yy4
	default:
		goto yy5
	}
yy5:
	{
					//fmt.Println("space:", yyinput[prev:yycursor])
					prev = yycursor
					continue
				}
yy6:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case '\n':
		goto yy6
	default:
		goto yy7
	}
yy7:
	{
					//fmt.Println("newline:", yyinput[prev:yycursor])
					prev = yycursor
					continue
				}
yy8:
	yycursor += 1
	yych = yyinput[yycursor]
	switch (yych) {
	case '/':
		goto yy9
	default:
		goto yy3
	}
yy9:
	yycursor += 1
	{
					scope = sS.push(ScopeComment)
					prev = yycursor
					continue
				}
}

		case ScopeComment:
			
{
	var yych byte
	yych = yyinput[yycursor]
	switch (yych) {
	case 0x00:
		goto yy11
	case '\n':
		goto yy13
	default:
		goto yy12
	}
yy11:
	yycursor += 1
	{ return errors.New("Unexpected end of input") }
yy12:
	yycursor += 1
	{
					prev = yycursor
					continue
				}
yy13:
	yycursor += 1
	{
					scope = sS.pop()
					prev = yycursor
					continue
				}
}


		}
	}
}
